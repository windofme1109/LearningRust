// 宏（macro）
// 术语宏 (macro)其实是Rust中的某一组相关功能的集合称谓
// 其中包括使用 macro_rules! 构造的声明宏(declarative macro)及另外3种过程宏 (procedural macro):
// • 用于结构体或枚举的自定义#[derive]宏，它可以指定随derive 属性自动添加的代码。
// • 用于为任意条目添加自定义属性的属性宏。
// • 看起来类似于函数的函数宏，它可以接收并处理一段标记 (token)序列。


// 宏与函数的区别

// 从根本上来说，宏是一种用于编写其他代码的代码编写方式，也就是所谓的元编程范式(metaprogramming)
// 这些宏会通过展开来生成比你手写代码更多的内容
// 元编程可以极大程度地减少你需要编写和维护的代码数量，虽然这也是函数的作用之一，但宏却有一些函数所不具备的能力

// 1. 函数在定义签名时必须声明自己参数的个数与类型，而宏则能够处理可变数量的参数: 
// 我们可以使用单一参数调用println! ("hello")，也可以使用两个参数调用println! ("hello {}", name)

// 2. 由于编译器会在解释代码前展开宏，所以宏可以被用来执行某些较为特殊的任务，比如为类型实现 trait 等
// 之所以函数无法做到这一点，是因为 trait 需要在编译时实现，而函数则是在运行时调用执行的

//  3. 当你在某个文件中调用宏时，你必须提前定义宏或将宏引入当前作用域中，而函数则可以在任意位置定义并在任意位置使用

// 宏的缺点
// 1. 宏的定义要比函数定义复杂得多，因为你需要编写的是用于生成Rust代码的 Rust 代码
// 正是由于这种间接性，宏定义通常要比函数定义更加难以阅读、理解及维护。


// 用于通用元编程的 macro_rules! 宏
// Rust中最常用的宏形式是声明宏，它们有时也被称作“模板宏” (macros by example)“macro_rules! 宏”，或者直白的“宏”
// 从核心形式上来讲，声明宏要求你编写出类似于 match 表达式的东西，match表达式是一种接收其他表达式的控制结构，它会将表达式的结果值与模式进行比较，并在匹配成功时执行对应分支中的代码
// 类似地，宏也会将输入的值与带有相关执行代码的模式进行比较: 此处的值是传递给宏的字面 Rust 源代码
// 而此处的模式则是可以用来匹配这些源代码的结构。当某个模式匹配成功时，该分支下的代码就会被用来替换传入宏的代码
// 所有的这一切都 会发生在编译时期

// 为了定义一个宏，你需要用到macro_rules!

// 使用 marco_rules! 宏定义一个简版的 vec!


fn main() {
    println!("Hello, world!");
}

// Rust 高级特性
// Unsafe Rust
// 不安全的 Rust
// 1. 不安全的 Rust 存在的意义
// 不安全 Rust 之所以存在是因为静态分析从本质上讲是保守的
// 当编译器在判断一段代码是否拥有某种安全保障时，它总是宁可错杀一些合法的程序也不会接受可能非法的代码
// 尽管某些代码也许是安全的，但目前的Rust编译器却可能会做出相反的结论
// 在这种情况下， 你可以使用不安全代码来告知编译器:“相信我，我知道自己在干些什么。”
// 这样做的缺点在于你需要为自己的行为负责:如果你错误地使用了不安全代码，那么就可能会引发不安全的内存问题，比如空指、针解引用等

// 另外一个需要不安全Rust的原因在于底层计算机硬件固有的不安全性。如果 Rust 不允许进行不安全的操作，那么某些底层任务可能根本就完成不了

// 总的来说，不安全的 Rust 存在的原因主要是包含两点：
// 1. 让开发者自己保证内存的安全
// 2. 提供使用底层不安全性操作的能力

// 提供四种在安全的 Rust 中不被允许的操作：
// 1. 解引用裸指针
// 2. 调用不安全的函数或方法
// 3. 访问或修改可变的静态变量
// 4. 实现不安全trait

// 使用 unsafe 关键字即可定义一段不安全的 Rust 代码

// 使用了 unsafe 标记代码，不意味代码一定是危险的、不安全的
// 它仅仅是将责任转移到了程序员的肩上，我们需要手动确定 unsafe 块中的代码会以合法的方式访问内存

// 为了尽可能地隔离不安全代码，你可以将不安全代码封装在一个安全的抽象中并提供一套安全的API，
// 某些标准库功能同样使用了审查后的不安全代码，并以此为基础提供了安全的抽象接口
// 这种技术可以有效地防止unsafe代码泄漏到任何调用它的地方，因为使用安全抽象总会是安全的

fn main() {
    // println!("Hello, world!");
    // 裸指针 Raw Pointer
    // 不安全Rust的世界里拥有两种类似于引用的新指针类型，它们都被叫作裸指针 (raw pointer)
    // 与引用类似，裸指针 要么是可变的，要么是不可变的，它们分别被写作*const T和*mut T
    // 这里的星号是类型名的一部分而不是解引用操作，在裸指针的上下文中，不可变意味着我们不能直接对解引用后的指针赋值
    // 裸指针与引用、智能指针的区别在于:
    // 1. 允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针
    // 2. 不能保证自己总是指向了有效的内存地址
    // 3. 允许为空
    // 4. 没有实现任何自动清理机制
    // 在避免 Rust 强制执行某些保障后，你就能够以放弃安全保障为代价来换取更好的性能
    // 或者换取与其他语言、硬件进行交互的能力 (Rust的保障在这些领域本来就不起作用)


    let mut num = 5;
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    // 注意，我们没有在这段代码中使用 unsafe 关键字,你可以在安全代码内合法地创建裸指针
    // 但不能在不安全代码块外解引用裸指针

    // 在创建裸指针的过程中，我们使用了 as 来分别将不可变引用和可变引用强制转换为了对应的裸指针类型
    // 由于这两个裸指针来自有效的引用，所以我们能够确认它们的有效性。但要记住，这一假设并不是对任意一个裸指针都成立

    
}

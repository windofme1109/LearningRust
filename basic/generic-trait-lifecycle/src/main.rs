// 生命周期
// Rust 中每个引用都有生命周期（lifetime），对应着引用保持有效的作用域
// 可以理解为，每个引用在声明其的作用域，都是有效的，这个有效的范围，就是引用的生命周期

// 生命周期可以避免悬垂引用

fn main() {
    // 外部作用域声明一个未初始化的变量
    let r;
    {
        // 内部作用域声明一个为 x 的变量
        let x = 5;
        // 将 r 的值设置为指向 x 的引用
        // borrowed value does not live long enough
        r = &x;
    }
    // 在外部作用域继续引用 r
    println!("r: {}", r);
    // 上面的代码会编译不通过，编译器提示：error[E0597]: `x` does not live long enough
    // x 在内部作用域（10 - 16 行）生效，在外部作用域，就会失效
    // 而 r 在整个作用域生效
    // 当我们在外部作用域打印 r 时，r 引用的 x 值，已经失效了，所以编译器提示 x 活的不够长（`x` does not live long enough）
    // 假如 Rust 允许这段代码运行，r 就会引用到在 x 离开作用域时已经释放的内存，即发生了悬垂引用，这时任何基于 r 所进行的操作都无法正确地进行

    // Rust 是如何确定上面的代码不合法呢

    // Rust编译器拥有一个借用检查器 （borrow checker），它被用于
    // 比较不同的作用域并确定所有借用的合法性
    // 我们可以标注一下上面出错的代码的生命周期
    // 
    // {                        // 
    //     let r;               // -----------------+----'a
    //     {                    //                  |
    //         let x = 5;       // --+--'b          |
    //         r = &x;          //   |              |
    //     }                    // --+--            |
    //                          //                  |
    //     println!("r: {}", r);// -----------------+
    // }                        //  

}
// 生命周期
// Rust 中每个引用都有生命周期（lifetime），对应着引用保持有效的作用域
// 可以理解为，每个引用在声明其的作用域，都是有效的，这个有效的范围，就是引用的生命周期

// 生命周期可以避免悬垂引用

fn main() {
    // 外部作用域声明一个未初始化的变量
    let r;
    {
        // 内部作用域声明一个为 x 的变量
        let x = 5;
        // 将 r 的值设置为指向 x 的引用
        // borrowed value does not live long enough
        r = &x;
    }
    // 在外部作用域继续引用 r
    println!("r: {}", r);
    // 上面的代码会编译不通过，编译器提示：error[E0597]: `x` does not live long enough
    // x 在内部作用域（10 - 16 行）生效，在外部作用域，就会失效
    // 而 r 在整个作用域生效
    // 当我们在外部作用域打印 r 时，r 引用的 x 值，已经失效了，所以编译器提示 x 活的不够长（`x` does not live long enough）
    // 假如 Rust 允许这段代码运行，r 就会引用到在 x 离开作用域时已经释放的内存，即发生了悬垂引用，这时任何基于 r 所进行的操作都无法正确地进行

    // Rust 是如何确定上面的代码不合法呢

    // Rust编译器拥有一个借用检查器 （borrow checker），它被用于
    // 比较不同的作用域并确定所有借用的合法性
    // 我们可以标注一下上面出错的代码的生命周期
    // 
    // {                        // 
    //     let r;               // -----------------+----'a
    //     {                    //                  |
    //         let x = 5;       // --+--'b          |
    //         r = &x;          //   |              |
    //     }                    // --+--            |
    //                          //                  |
    //     println!("r: {}", r);// -----------------+
    // }                        //  

    // 我们将r的生命周期标注为了 'a，并将 x 的生命周期标注为了 'b
    // 内部的'b代码块要小于外部的'a 生命周期代码块，就是说， r 的作用域显然大于 x 的作用域
    // 在编译过程中，Rust 会比较两段生命周期的大小，并发现 r 拥有生命周期 'a，但却指向了拥有生命周期 'b 的内存
    // 这段程序会由于 'b 比 'a 短而被拒绝通过编译：被引用对象的存在范围短于引用者

    // {                        // 
    //     let x = 5;           // -----------------+----'b
    //                          //                  |
    //     let r = &x;          // --+--'a          |
    //                          //   |              |
    //     println!("r: {}", r);// --+--            |
    //                          //                  |
    //                          // -----------------+
    // }                        //  

    // 将代码修正为上面的格式，显然是可以通过编译的，因为数据 x 的生命周期（作用域）显然大于引用的生命周期（作用域）
    // x 拥有长于 'a 的生命周期 'b。这也意味着 r 可以引用 x 了，因为 Rust 知道 r 中的引用在 x 有效时会始终有效

}


// 比较两个字符串的长度，并返回最长的那个
// 直接编译，会报错：
// error[E0106]: missing lifetime specifier
// help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
fn longest(x: &str, y: &str) -> &str {
    if (x.len() > y.len()) {
        x
    } else {
        y
    }
}
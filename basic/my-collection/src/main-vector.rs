fn main() {
   // Rust 中的集合

    // 1. 动态数组 Vec<T>
    // 动态数组允许你在单个数据结构中存储多个相同类型的值
    // 这些值会彼此相邻地排布在内存中。动态数组非常适合在需要存储一系列相同类型值的场景中使用
    // 同时还可以动态的向其中插入值
    // 创建一个动态数组，同时指定元素的类型
    let v: Vec<i32> = Vec::new();

    // 使用宏创建一个带初始值的动态数组
    let v2 = vec![1, 2, 3];

    // 如果我们创建数组时不指定数据类型，然后插入一个值，Rust 也能推断出数组的元素的类型
    // 我们只需要在极少数的场景中对类型进行声明
    let mut v3 = Vec::new();
    //
    v3.push(1);

    // 动态更新数组
    // 使用 push 向数组内添加元素，但是需要注意的时，要将数组声明为可变的
    let mut v4 = Vec::new();
    v4.push(1);
    v4.push(2);
    v4.push(3);

    // 注意，离开作用域时，动态数组会被销毁，同时其内部的元素也会被销毁

    // 获取动态数组的元素
    let v5 = vec![1, 2, 3, 4, 5];
    // 1. 通过索引的方式获取，使用&与[]会直接返回元素的引用；
    let third: &i32 = &v5[2];
    // 2. 通过 get 方法获取，接收索引作为参数的 get 方法则会返回一个 Option<&T>
    match v5.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
    // 对于数组越界的情况，两种获取数组元素的方法表现不同：
    // 使用索引的方式访问数组的元素，当索引指向了不存在的元素会导致程序触发 panic
    // 假如你希望在尝试越界访问元素时使程序直接崩溃，那么就可以使用这种方式访问数组的元素
    // let does_not_exist = &v5[100];
    // get方法会在检测到索引越界时简单地返回 None 这个变体，而不是使程序直接崩溃
    // 当偶尔越界访问动态数组中的元素是一个正常行为时，应该使用这个方法
    // 这样可以方便的处理异常
    // let does_not_exist = v5.get(100);

    // 遍历一个动态数组
    // 直接使用 for in 循环
    let v6 = vec![100, 32, 57];
    // i 是对不可变数组 v6 中的 i32 元素的不可变引用
    for i in &v6 {
        println!("value is {}", i);
    }

    // 我们可以遍历可变的动态数组，获得元素的可变引用，并修改其中的值

    // 创建一个可变数组，并使用 mut 关键字修饰，表示可以修改其中的元素
    let mut v7 = vec![100, 32, 57];
    // 对 v7 的一个可变引用
    for i in &mut v7 {
        // 为了使用 += 运算符来修改可变引用指向的值，我们首先需要使用 解引用运算符(*)来获得i绑定的值
        *i += 50;
        println!("value is {}", i);
    }

    // 如果我们已经有了对数组某个元素的不可变引用，那么我们如果再操作数组，如添加、删除元素
    // 这种操作实际上是不会成功的
    // error[E0502]: cannot borrow `v8` as mutable because it is also borrowed as immutable
    let mut v8 = vec![1, 2, 3, 4, 5];
    // first 是指向 v8 的第一个元素的不可变引用
    // 此时 v8 已经借用为不可变引用
    // let first = &v8[0];
    // 此时调用 v8 的 push 方法，等同于将 v8 借用为可变引用
    // 而 Rust 所有权规则，不能在同一个作用域内对一个值同时拥有可变引用和人不可变引用
    // 所以 push 行为会失败
    // v8.push(6);

    // println!("The first element is: {}", first);

    // 下面从动态数组的工作原理出发，解释一下为为什么对动态数组元素的不可变引用不能与操作数组共存
    // 为什么对第一个元素的引用需要关心动态数组结尾处的变化呢?
    // 此处的错误是由动态数组的工作原理导致的
    // 动态数组中的元素是连续存储的，插入新的元素后也许会没有足够多的空间将所有元素依次相邻地放下
    // 这就需要分配新的内存空间，并将旧的元素移动到新的空间上
    // 在上面的例子中，第一个元素的引用可能会因为插入行为而指向被释放的内存
    // 借用规则 可以帮助我们规避这类问题


    // 使用 enum 给动态数组添加不同类型的值
    // 动态数组只能存储相同类型的值，如果是想要存储不同类型的值，我们需要借助枚举来完成
    
    // 假设我们希望读取表格中的单元值，这些单元值可能是整数、浮点数或字符串
    // 那么就可以使用枚举的不同变体来存放不同类型的值
    // 所有的这些枚举变体都会被视作统一的类型: 也就是这个枚举类型
    // 接着，我们便可以创建一个持有该枚举类型的动态数组来存放不同类型的值
    enum SpreadSheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    // 动态数组存放的类型是枚举类型，具体的值是枚举的变体
    // 因此可以实现存放多种不同的类型的值
    let row = vec![
        SpreadSheetCell::Int(3),
        SpreadSheetCell::Float(10.12),
        SpreadSheetCell::Text(String::from("blue"))
    ];


    // println!("Hello, world!");
}

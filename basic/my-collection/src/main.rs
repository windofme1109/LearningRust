fn main() {
   // Rust 中的集合

    // 1. 动态数组 Vec<T>
    // 动态数组允许你在单个数据结构中存储多个相同类型的值
    // 这些值会彼此相邻地排布在内存中。动态数组非常适合在需要存储一系列相同类型值的场景中使用
    // 同时还可以动态的向其中插入值
    // 创建一个动态数组，同时指定元素的类型
    let v: Vec<i32> = Vec::new();

    // 使用宏创建一个带初始值的动态数组
    let v2 = vec![1, 2, 3];

    // 如果我们创建数组时不指定数据类型，然后插入一个值，Rust 也能推断出数组的元素的类型
    // 我们只需要在极少数的场景中对类型进行声明
    let mut v3 = Vec::new();
    //
    v3.push(1);

    // 动态更新数组
    // 使用 push 向数组内添加元素，但是需要注意的时，要将数组声明为可变的
    let mut v4 = Vec::new();
    v4.push(1);
    v4.push(2);
    v4.push(3);

    // 注意，离开作用域时，动态数组会被销毁，同时其内部的元素也会被销毁

    // 获取动态数组的元素
    let v5 = vec![1, 2, 3, 4, 5];
    // 1. 通过索引的方式获取，使用&与[]会直接返回元素的引用；
    let third: &i32 = &v5[2];
    // 2. 通过 get 方法获取，接收索引作为参数的 get 方法则会返回一个 Option<&T>
    match v5.get(2) {
        Some(third) => println!("The third element is {}", third),
        None => println!("There is no third element."),
    }
    // 对于数组越界的情况，两种获取数组元素的方法表现不同：
    // 使用索引的方式访问数组的元素，当索引指向了不存在的元素会导致程序触发 panic
    // 假如你希望在尝试越界访问元素时使程序直接崩溃，那么就可以使用这种方式访问数组的元素
    let does_not_exist = &v5[100];
    // get方法会在检测到索引越界时简单地返回 None 这个变体，而不是使程序直接崩溃
    // 当偶尔越界访问动态数组中的元素是一个正常行为时，应该使用这个方法
    let does_not_exist = v5.get(100);
    // println!("Hello, world!");
}

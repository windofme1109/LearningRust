
// 所有权
// 其目的是更高效的管理堆内存，避免出现内存管理方面的问题

// 三条规则
// Rust中的每一个值都有一个对应的变量作为它的所有者
// 在同一时间内，值有且仅有一个所有者
// 当所有者离开自己的作用域时，它持有的值就会被释放掉

// fn main() {
//     // 未声明前 s 不可用
//     // 作用域
//     let s = "hello";  // s 可用
//     // 可以对 s 进行相关操作
//
//
// } // s 的作用域到此结束，s 不可再用

fn main() {

    // 字面量形式的字符串，因为其大小固定，因此可以将其完整的存放在栈内存中
    let s0 = "hello world";
    let ss = s0;
    //
    println!("{}, {}", s0, ss);
    // 创建一个 String 类型
    // String 类型比较复杂，所需要的空间不确定，所以系统会去堆内存中申请一块区域，来存放数据，因此其真正的值被放到堆内存中
    // 而栈内存存放一个指向堆内存的指针以及其他信息
    // s 就是绑定的栈内存的信息
    let mut s = String::from("hello");
    s.push_str(", world");
    println!("{}", s);

    let s1 = String::from("hello");
    // 对于 String 这种复杂的数据结构而言
    // 正常来说，s2 = s1，这个赋值操作，按照我们通常的做法：是指针复制一份，然后 s1 和 s2 共同指向同一份堆内存的数据
    // 但是，这就导致了一个问题：当 s2 和 s1 离开自己的作用域时，它们会尝试去重复释放相同的内存（因为指向了同一块堆内存）
    // 这也就是一个知名的内存错误：臭名昭著的二次释放。
    // 重复释放内存可能会导致某些正在使用的数据发生损坏，进而产生潜在的安全隐患

    // 为了确保内存安全，同时也避免复制分配的内存，Rust在这种场景下会简单地将s1废弃，不再视其为一个有效的变量
    let s2 = s1;
    // 所以在执行完 s2 = s1 以后，s1 就被废弃了，后面我们是无法使用 s1 的
    // error[E0382]: borrow of moved value: `s1`
    // println!("{}, {}", s1, s2);

    // 其他语言，例如 JavaScript 中 有浅度拷贝 （shallow copy）和深度拷贝 （deep copy）的概念
    // 对于 s2 = s1 这个操作可以理解为是浅拷贝操作，但由于 Rust同时使第一个变量无效
    // 所以这里使用了新的术语：移动 （move）来描述这一行为，而不再使用浅度拷贝
    // 移动（move）这个属于比较形象，也就是将 s1 所表示的栈中的数字，移动到 s2 那里，然后 s1 就被废弃了
    // 因为 s1 被废弃，所以始终只有一个变量指向一块堆内存，因此不会出现内存的二次释放问题

    // Rust永远不会自动地创建数据的深度拷贝

    // 如果我想要复制堆内存上的数据，如 s1，那么 Rust 提供了一个 clone 的方法，clone 方法可以理解为是深复制方法
    // 示例如下

    let s3 = String::from("hello");
    let s4 = s3.clone();

    println!("{}, {}", s3, s4);

    // 栈上面的数据的复制

    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
    // y = x，并没有发生移动，x 依旧有效
    // 这是因为类似于整型的类型可以在编译时确定自己的大小，并且能够将自己的数据完整地存储在栈中
    // 对于这些值的复制操作永远都是非常快速的
    // 因此，创建 y 以后，y 的数据也是完整的存放在栈内存中，所以我们没有必要去废弃 x
    // 对于这种数据全部在栈内存中的变量进行复制，深复制和浅复制没有任何区别
    // 类似于 JavaScript 中基本类型的复制（深拷贝）
    //
    // 更进一步说，Rust 提供一个名为 Copy 的 trait，它可以用于整数这类完全存储在栈上的数据类型
    // 一旦某种类型拥有了 Copy 这种 trait，那么它的变量就可以在赋值给其他变量之后保持可用性。
    // 如果一种类型本身或这种类型的任意成员实现了 Drop 这种 trait
    // 那么 Rust 就不允许其实现 Copy 这种 trait
    // 尝试给某个需要在离开作用域时执行特殊指令的类型实现 Copy 这种 trait 会导致编译时错误

    // 实现了 Copy 的类型，就可以实现深复制
    // 实现了 Drop 的类型，就不再允许其实现 Copy，否则会报错

    // 哪些类型是可以 copy 的呢？
    // 1. 任何简单标量的组合类型都可以是Copy的，
    // 2. 任何需要分配内存或某种资源的类型都不会是 Copy 的

    // 举个例子，下面列举的都是 可以 copy 的
    // 1. 所有的整数类型，诸如u32。
    // 2. 仅拥有两种值（true和false）的布尔类型：bool。
    // 3. 字符类型：char。
    // 4. 所有的浮点类型，诸如f64。
    // 5. 如果元组包含的所有字段的类型都是Copy的，那么这个元组也是Copy的。例如，(i32, i32)是Copy的，但(i32, String)则不是。
    // 6. 字面量形式的字符串

    // 所有权与函数
}

// 状态模式(state pattern)是一种面向对象的设计模式
// 它的关键特点是，一个值拥有的内部状态由数个状态对象(state object) 表达而成,而值的行为则随着内部状态的改变而改变
// 这种设计模式会通过状态对象来共享功能

// 相对应地，Rust 使用了结构体与 trait 而不是对象与继承来实现这一特性。
// 每个状态对象都会负责自己的行为并掌控自己转换为其他状态的时机
// 而持有状态对象的值则对状态的不同行为和状态转换的时机一无所知
// 使用状态模式意味着在业务需求发生变化时我们不需要修改持有状态对象的值，或者使用这个值的代码
// 我们只需要更新状态对象的代码或增加一些新的状态对象，就可以改变程序的运转规则


// 举一个博客的例子来实现状态模式，这个例子会采用增量式的开发过程来实现一个用于发布博客的工作流程
// 这个博客最终的工作流程如下:
// 1. 在新建博客文章时生成一份空白的草稿文档。
// 2. 在草稿撰写完毕后，请求对这篇草稿状态的文章进行审批。
// 3. 在文章通过审批后正式对外发布。
// 4. 仅返回并打印成功发布后的文章，而不能意外地发布没有通过审批的文章。

// 除了上面描述的流程，任何其他对文章的修改行为都应当是无效的
// 例如，假设某人试图跳过审批过程来直接发布草稿状态的文章， 那么我们的程序应当阻止这一行为并保持文章的草稿状态


use blog::Post;

// todo
// 1. 添加reject方法，它可以将文章的状态从 PendingReview 修改为 Draft
// 2. 为了将文章状态修改为 Published ， 用 户 需 要 调 用 两 次 approve
// 3. 用户只有在文章处于 Draft 状态时才能够修改文本内容（提示：将改变内容的职责从Post转移至状态对象）


// 状态模式的缺点
// 1. 因为状态实现了状态间的转移，所以某些状态之间是相互耦合的
// 如果我们希望在 PendingReview 和 Published 之间添加一个 Scheduled 状态 ， 那么我们就需要修改 PendingReview 中的代码来转移到 Scheduled 状态
// 假如我们能够在新增状态时避免修改 PendingReview，那么虽然这会更加方便，但也意味着我们需要选用另外一种设计模式
// 2. 我们需要重复实现一些代码逻辑
// 你也许会试着提供默认实现，让 State trait 的request_review 和approve 方法默认返回 self
// 但这样的代码违背了对象安全规则，因为 trait 无法确定 self 的具体类型究竟是什么
// 如果我们希望将 State 当作 trait 对象来使用，那么它的方法就必须全部是对象安全的。

fn main() {
    // println!("Hello, world!");
    let mut post = Post::new();
    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
    post.request_review();
    assert_eq!("", post.content());
    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}

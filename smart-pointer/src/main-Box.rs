
// 指针
// 指针（pointer）是一个通用概念，它指代那些包含内存地址的变量
// 这个地址被用于索引，或者说用于“指向”内存中的其他数据

// 智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但拥有额外的元数据和附加功能

// 引用和智能指针之间还有另外一个差别：引用是只借用数据的指针；
// 而与之相反地，大多数智能指针本身就拥有它们指向的数据

// 使用结构体来实现智能指针，但区别于一般结构体的地方在于它们会实现 Deref 与 Drop 这两个 trait
// Deref trait 使得智能指针结构体的实例拥有与引用一致的行为，它使你可以编写出能够同时用于引用和智能指针的代码
// Drop trait 则使你可以自定义智能指针离开作用域时运行的代码


fn main() {
    // 使用Box<T>在堆上分配数据
    // 装箱（box）是最为简单直接的一种智能指针，它的类型被写作 Box<T>
    // 装箱使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针

    // 除了将它们的数据存储在堆上而不是栈上，装箱没有其他任何的性能开销
    // 当然，它们也无法提供太多的额外功能。装箱常常被用于下面的场景中：
    // 1. 当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时
    // 2. 当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时
    // 3. 当你希望拥有一个实现了指定 trait 的类型值，但又不关心具体的类型时


    // 使用装箱在堆上存储一个 i32 类型的数据
    let b = Box::new(5);

    println!("b = {}", b);


    // 使用装箱定义递归类型
    // Rust 必须在编译时知道每一种类型占据的空间大小
    // 但有一种被称作递归 （recursive）的类型却无法在编译时被确定具体大小
    // 递归类型的值可以在自身中存储另一个相同类型的值，因为这种嵌套在理论上可以无穷无尽地进行下去
    // 所以 Rust 根本无法计算出一个递归类型需要的具体空间大小
    // 装箱有一个固定的大小，我们只需要在递归类型的定义中使用装箱便可以创建递归类型了

    // 链接列表
    // Rust 必须在编译时知道每一种类型占据的空间大小，但有一种被称作递归 （recursive）的类型却无法在编译时被确定具体大小
    // 递归类型的值可以在自身中存储另一个相同类型的值，因为这种嵌套在理论上可以无穷无尽地进行下去
    // 所以 Rust 根本无法计算出一个递归类型需要的具体空间大小
    // 但是，装箱有一个固定的大小，我们只需要在递归类型的定义中使用装箱便可以创建递归类型了

    // 下面来看一个递归类型的例子，一个在函数式编程语言中相当常见的数据类型：链接列表（cons list）
    // 除了递归部分，我们将使用较为直接的方式来定义这个链接列表类型
    //
    // 链接列表是一种来自 Lisp 编程语言与其方言的数据结构
    // 在 Lisp 中，cons函数（也就是构造函数的缩写）会将两个参数组成一个二元组
    // 而这个元组通常由一个值与另一个二元组组成，通过这种不断嵌套元组的形式可以最终组成一个列表

    // 链接列表的每一项都包含了两个元素：当前项的值及下一项。列表中的最后一项是一个被称作 Nil 且不包含下一项的特殊值
    // 我们通过反复调用cons函数来生成链接列表，并使用规范名称 Nil 来作为列表的终止标记
    // 注意，这不同于 “null” 概念，Nil 并不是一个无效或缺失的值

    // 链接列表有点类似于链表：链表的节点有一个 next 指针指向下一个节点，节点还存放了数据，最后一个节点的 next 指针指向空

    // 当然，在 Rust 中，链接列表并不常见，当你需要在Rust中持有一系列的元素时，Vec<T> 在大部分情况下都会是一个更好的选择

    // 示例：使用枚举定义一个链接列表

    // 使用List枚举存储列表1, 2, 3
    // 第一个 Cons 变体包含了 1 和另外一个 List 值，这个 List 值作为另外一个 Cons 变体包含了 2 和另外一个List值
    // 这个 List 依然是一个 Cons 变体，它包含了 3 与一个特殊的 List 值，也就是最终的非递归变体 Nil，它代表了列表的结束
    // let list = Cons(1, Cons(2, Cons(3, Nil)));

    // 直接编译，会发生报错：
    // error[E0072]: recursive type `List` has infinite size
    // 这是因为我们在定义 List 时引入了一个递归的变体，它直接持有了另一个相同类型的值
    // 这意味着 Rust 无法计算出存储一个 List 值需要消耗多大的空间

    // 使用 Box<T> 指针修改递归的数据类型
    let list = Cons(
        1,
        Box::new(Cons(
            2,
            Box::new(Cons(
                3,
                Box::new(Nil)))))
    );
}
use crate::List::{Cons, Nil};

// 定义一个枚举来表达一个持有 i32 值的链接列表数据类型
enum List {
    // Cons 变体持有两个类型，一个类型是 i32，另外一个是 List 枚举，这里就形成了递归
    // 直接存储 List 值是不行的，所以我们应该改变思路：改变存储的数据结构，不直接存储值，而是存储指向这个值的指针

    // 因为 Box<T> 是一个指针，所以 Rust 总是可以确定一个 Box<T> 的具体大小
    // 指针的大小总是恒定的，它不会因为指向数据的大小而产生变化
    // 这也意味着我们可以在 Cons 变体中存放一个 Box<T> 而不是直接存放另外一个 List 值
    // 而 Box<T> 则会指向下一个 List 并存储在堆上，而不是直接存放在 Cons 变体中
    // 理论上讲，我们仍然拥有一个“持有”其他列表的列表，但现在的实现更像是一项挨着一项，而不是一项包含另一项

    // 使用 Box<T>，我们获取的是指向值的指针，而不是真正的包含了这个值
    // Cons(i32, List),
    // Cons 变体需要一部分存储i32的空间和一部分存储装箱指针数据的空间
    Cons(i32, Box<List>),
    Nil
}

// 定义一个非递归类型的枚举
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

// 为了计算出 Message 值需要多大的存储空间，Rust会遍历枚举中的每一个成员来找到需要最大空间的那个变体。
// 在编译器看来：
// Message::Quit 不需要占用任何空间，Message::Move 需要两个存储 i32值的空间
// 以此类推。因为在每个时间点只会有一个变体存在，所以 Message 值需要的空间大小也就是能够存储得下最大变体的空间大小
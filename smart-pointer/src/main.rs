// RcCell<T>

// 内部可变性 （interior mutability）是Rust的设计模式之一，它允许我们在只持有不可变引用的前提下对数据进行修改
// 通常而言，类似的行为会被借用规则所禁止。为了能够改变数据，内部可变性模式在它的数据结构中使用了unsafe（不安全）代码来绕过Rust正常的可变性和借用规则

// RcCell<T> 会跳过编译期的借用规则检查，而是在运行期检查借用规则，一旦出现违反借用规则的情况下，就会触发panic来提前中止程序

// 与 Rc<T> 相似，RefCell<T> 只能被用于单线程场景中。强行将它用于多线程环境中会产生编译时错误

// 下面是选择使用 Box<T>、Rc<T> 还是 RefCell<T> 的依据：
// 1. Rc<T> 允许一份数据有多个所有者，而 Box<T> 和 RefCell<T> 都只有一个所有者。
// 2. Box<T> 允许在编译时检查的可变或不可变借用，Rc<T> 仅允许编译时检查的不可变借用，RefCell<T> 允许运行时检查的可变或不可变借用
// 3. 由于 RefCell<T> 允许我们在运行时检查可变借用，所以即便 RefCell<T> 本身是不可变的，我们仍然能够更改其中存储的值

fn main() {
    // 内部可变性：可变地借用一个不可变的值
    // 借用规则的一个推论是，你无法可变地借用一个不可变的值
    // error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
    //     let x = 5;
    //     let y = &mut x;

    // 然而，在某些特定情况下，我们也会需要一个值在对外保持不可变性的同时能够在方法内部修改自身
    // 除了这个值本身的方法，其余的代码则依然不能修改这个值
    // 使用 RefCell<T> 就是获得这种内部可变性的一种方法
    // RefCell<T> 并没有完全绕开借用规则：我们虽然使用内部可变性通过了编译阶段的借用检查
    // 但借用检查的工作仅仅是被延后到了运行阶段。如果你违反了借用规则，那么就会得到一个 panic! 而不再只是编译时的错误。
}